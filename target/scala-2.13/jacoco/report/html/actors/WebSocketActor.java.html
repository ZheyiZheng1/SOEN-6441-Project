<?xml version="1.0" encoding="utf-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>WebSocketActor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=2;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">Jacoco Coverage Report</a> &gt; <a href="index.source.html" class="el_package">actors</a> &gt; <span class="el_source">WebSocketActor.java</span></div><h1>WebSocketActor.java</h1><pre class="source lang-java linenums">package actors;

import akka.actor.AbstractActor;
import akka.actor.ActorRef;
import akka.actor.OneForOneStrategy;
import akka.actor.Props;
import akka.actor.SupervisorStrategy;
import akka.actor.Cancellable;
import akka.japi.pf.DeciderBuilder;

import com.fasterxml.jackson.databind.JsonNode;
import scala.concurrent.duration.Duration;
import services.YTResponse;

import javax.inject.Inject;
import java.util.LinkedList;
import java.util.List;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.TimeoutException;
import java.util.stream.Collectors;
import java.util.stream.IntStream;

import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.node.ObjectNode;
import com.fasterxml.jackson.databind.node.ArrayNode;

import static actors.WordStatsActor.wordStatsMap;
import static java.util.concurrent.TimeUnit.SECONDS;

/**
 * @author: Zheyi Zheng - 40266266
 * Created: 2024/11/14
 * This is the WebSocketActor class. This class keeps websocket with user, receive keyword from user,
 * forward keyword to APIActor, keep all search results and return all search results to user.
 * WebSocketActor is also the supervisor to all other actors. Home controller also only knows about WebSocketActor.
 */
public class WebSocketActor extends AbstractActor {

    private final ActorRef out;
    private String keyword;
    private ActorRef apiActor;
    private ActorRef readabilityActor;
    private ActorRef sentimentActor;
    private ActorRef wordStatsActor;
    // keep searched keywords
    private List&lt;String&gt; searchHistory;
    // Keep search results
    private List&lt;List&lt;YTResponse&gt;&gt; searchResults;
    private List&lt;Double&gt; avgFKGL;
    private List&lt;Double&gt; avgFRE;
    private String stm;
    // Scheduler for periodic updates
    private Cancellable refreshScheduler;
    // Default refresh interval
<span class="fc" id="L55">    private int refreshInterval = 10;</span>

<span class="fc" id="L57">    private final SupervisorStrategy strategy = new OneForOneStrategy(</span>
            -1,
<span class="fc" id="L59">            java.time.Duration.ofMinutes(3),</span>
<span class="fc" id="L60">            DeciderBuilder.match(TimeoutException.class,</span>
                    // Timeout exception, should be able to resolve in the next message, so resume.
                    e -&gt; SupervisorStrategy.resume()
<span class="fc" id="L63">            ).match(RuntimeException.class,</span>
                    // Runtime exception, probably not be able to get resolve by itself, restart it.
                    e -&gt; SupervisorStrategy.restart()
<span class="fc" id="L66">            ).matchAny(</span>
                    // Any other issue, escalate it to actor system.
                    e -&gt; SupervisorStrategy.escalate()
<span class="fc" id="L69">            ).build()</span>
    );

    /**
     * @author: Zheyi Zheng - 40266266
     * Created: 2024/11/14
     * Define the supervise strategy.
     */
    @Override
    public SupervisorStrategy supervisorStrategy(){
<span class="fc" id="L79">        return strategy;</span>
    }

    /**
     * @author: Zheyi Zheng - 40266266
     * Created: 2024/11/14
     * This is the constructor method.
     */
    @Inject
<span class="fc" id="L88">    public WebSocketActor(ActorRef out) {</span>
<span class="fc" id="L89">        this.out = out;</span>
<span class="fc" id="L90">        this.apiActor = getContext().actorOf(APIActor.getProps());</span>
<span class="fc" id="L91">        this.readabilityActor = getContext().actorOf(ReadabilityActor.getProps());</span>
<span class="fc" id="L92">        this.sentimentActor = getContext().actorOf(SentimentActor.props());</span>
<span class="fc" id="L93">        this.wordStatsActor = getContext().actorOf(WordStatsActor.getProps());</span>
<span class="fc" id="L94">        this.searchHistory = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L95">        this.searchResults = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L96">        this.avgFKGL = new LinkedList&lt;&gt;();</span>
<span class="fc" id="L97">        this.avgFRE = new LinkedList&lt;&gt;();</span>
        // Start the scheduler for keep refresh
<span class="fc" id="L99">        startScheduler();</span>
<span class="fc" id="L100">    }</span>

    /**
     * @author: Zheyi Zheng - 40266266
     * Created: 2024/11/14
     * This is the getProps method. This method allows Props create APIActor.
     * @param out from Flow.
     * @return Props Proper return object in Akka
     */
    static public Props props(ActorRef out) {
<span class="fc" id="L110">        return Props.create(WebSocketActor.class, () -&gt; new WebSocketActor(out));</span>
    }

    /**
     * @author: Zheyi Zheng - 40266266
     * Created: 2024/11/14
     * This is the createReceive method. This method distinguish messages.
     * If the message is a string class, then it's a request message from user. Add the keyword to list and send keyWordSearch message to APIActor.
     * If the message is a CompletableFuture, then this is a response from APIActor. Read the information out and return new result to user.
     * @return Receive proper return object in Akka
     */
    @SuppressWarnings(&quot;unchecked&quot;)
    @Override
    public Receive createReceive() {
<span class="fc" id="L124">        return receiveBuilder()</span>
<span class="fc" id="L125">                .match(String.class, keyword -&gt; {</span>
                    System.out.println(&quot;Received keyword: &quot; + keyword);
                    this.keyword = keyword;
                    // Check if the keyword is already inside the searchHistory
                    if (searchHistory.contains(keyword)){
                        // The keyword is in the searchHistory, just change the order of all information.
                        // Get index of this keyword
                        int index = searchHistory.indexOf(keyword);
                        // Retrieve all information from list
                        double targetAvgFre = avgFRE.get(index);
                        double targetAvgFkgl = avgFKGL.get(index);
                        List&lt;YTResponse&gt; targetResult = searchResults.get(index);
                        // Delete the original copy
                        searchHistory.remove(index);
                        avgFRE.remove(index);
                        avgFKGL.remove(index);
                        searchResults.remove(index);
                        // Add the result back at the last place of all lists.
                        searchHistory.add(keyword);
                        avgFRE.add(targetAvgFre);
                        avgFKGL.add(targetAvgFkgl);
                        searchResults.add(targetResult);
                    }else {
                        // The keyword is not in the searchHistory, fetch information from the YouTube
                        if (searchHistory.size() &gt;= 10) {
                            // Remove the oldest entry if size exceeds 10
                            searchHistory.remove(0);
                        }
                        // Store the keyword in search history
                        searchHistory.add(keyword);
                        // Forward the keyword to the APIActor for processing
                        apiActor.tell(new ProjectProtocol.KeyWordSearch(keyword, null, null), getSelf());
                    }
                })
<span class="fc" id="L159">                .match(CompletableFuture.class, future -&gt; {</span>
                    System.out.println(&quot;Received CompletableFuture&quot;);
                    // Wait for the APIActor to return the search results
                    future.thenAccept(results -&gt; {
                        // Send a message to the ReadabilityActor
                        readabilityActor.tell(new ProjectProtocol.ReadabilityCheck(future), getSelf());
                        // Send a message to the SentimentActor
                        sentimentActor.tell(new ProjectProtocol.SentimentCheck(future), getSelf());
                        // Store the result in search results, only keep 10 most recent results


                        List&lt;YTResponse&gt; ytResponses = (List&lt;YTResponse&gt;) results;
                        List&lt;String&gt; descriptions = ytResponses.stream()

                                .map(YTResponse::getDescription)

                                .collect(Collectors.toList());

                        wordStatsActor.tell(new ProjectProtocol.WordStatsRequest(this.keyword,ytResponses), getSelf());






                        if (searchResults.size() &gt;= 10) {
                            searchResults.remove(0);
                        }
                        searchResults.add((List&lt;YTResponse&gt;) results);
                    });
                })
<span class="fc" id="L190">                .match(ProjectProtocol.ReadabilityResponse.class, message -&gt; {</span>
                    System.out.println(&quot;Received ReadabilityResponse&quot;);
                    // Receive readability response from the ReadabilityActor
                    double avgFRE = message.avgFRE;
                    double avgFKGL = message.avgFKGL;
                    List&lt;Double&gt; fre = message.fre;
                    List&lt;Double&gt; fkgl = message.fkgl;
                    for (int i=0; i&lt;searchResults.get(searchResults.size()-1).size(); i++){
                        searchResults.get(0).get(i).setFre(fre.get(i));
                        searchResults.get(0).get(i).setFkgl(fkgl.get(i));
                    }

                    // Store the result in search results, only keep 10 most recent results
                    if (this.avgFKGL.size() &gt;= 10) {
                        this.avgFKGL.remove(0);
                    }
                    if (this.avgFRE.size() &gt;= 10) {
                        this.avgFRE.remove(0);
                    }
                    this.avgFKGL.add(avgFKGL);
                    this.avgFRE.add(avgFRE);
                })
<span class="fc" id="L212">                .match(ProjectProtocol.UpdateApiAndReadabilityRef.class, message -&gt;{</span>
                    // This should not be used, it is created for test purpose.
                    this.apiActor=message.apiActor;
                    this.readabilityActor=message.readabilityActor;
                })
<span class="fc" id="L217">                .match(ProjectProtocol.SentimentResponse.class,message -&gt;{</span>
                 System.out.println(&quot;Received SentimentResponse&quot;);
                    this.stm = message.sentiment;
                })
<span class="fc" id="L221">                .match(RefreshResults.class, message -&gt; {</span>
                    // The scheduler called, check if there is any update of data and refresh on user side.
                    System.out.println(&quot;Refreshing&quot;);
                    // Call APIActor with UpdateDataRequest message, allows APIActor to check if there is any update on YouTube side.
                    searchHistory.stream().
                            forEach(keyword -&gt; apiActor.tell(new ProjectProtocol.UpdateDataRequest(keyword, null, null), getSelf()));

                    // Send all data back to user
                    // Create a JSON response
                    ObjectMapper mapper = new ObjectMapper();
                    ObjectNode root = mapper.createObjectNode();

                    // Add keywords as JSON array
                    ArrayNode searchHistoryArray = mapper.createArrayNode();
                    searchHistory.stream()
                            .sorted((a, b) -&gt; Integer.compare(searchHistory.indexOf(b), searchHistory.indexOf(a)))
                            .forEach(searchHistoryArray::add);
                    root.set(&quot;searchHistory&quot;, searchHistoryArray);
                    // Add avgFKGL and avgFRE as JSON arrays
                    ArrayNode avgFKGLArray = mapper.createArrayNode();
                    avgFKGL.stream()
                            .sorted((a, b) -&gt; Double.compare(avgFKGL.indexOf(b), avgFKGL.indexOf(a)))
                            .forEach(avgFKGLArray::add);
                    root.set(&quot;avgFKGL&quot;, avgFKGLArray);

                    ArrayNode avgFREArray = mapper.createArrayNode();
                    avgFRE.stream()
                            .sorted((a, b) -&gt; Double.compare(avgFRE.indexOf(b), avgFRE.indexOf(a)))
                            .forEach(avgFREArray::add);
                    root.set(&quot;avgFRE&quot;, avgFREArray);

                    // Add sentiment iformation (stm) as JSON arrays
                    ArrayNode stmArray = mapper.createArrayNode();
                    stmArray.add(this.stm);
                    root.set(&quot;stm&quot;,stmArray);

                    // Add searchResults as an array of arrays
                    ArrayNode searchResultsArray = mapper.createArrayNode();
                    searchResults.stream()
                            .sorted((a, b) -&gt; Integer.compare(searchResults.indexOf(b), searchResults.indexOf(a)))
                            .forEach(resultList -&gt; {
                                ArrayNode resultArray = mapper.createArrayNode();
                                resultList.forEach(result -&gt; {
                                    ObjectNode resultNode = mapper.createObjectNode();
                                    resultNode.put(&quot;title&quot;, result.getTitle());
                                    resultNode.put(&quot;videoID&quot;, result.getVideoId());
                                    resultNode.put(&quot;videoLink&quot;, result.getVideoLink());
                                    resultNode.put(&quot;channelTitle&quot;, result.getChannelTitle());
                                    resultNode.put(&quot;channelID&quot;, result.getChannelId());
                                    resultNode.put(&quot;channelProfileLink&quot;, result.getChannelProfileLink());
                                    resultNode.put(&quot;description&quot;, result.getDescription());
                                    resultNode.put(&quot;thumbnailUrl&quot;, result.getThumbnailUrl());
                                    resultNode.put(&quot;fkgl&quot;, result.getFkgl());
                                    resultNode.put(&quot;fre&quot;, result.getFre());
                                    resultArray.add(resultNode);
                                });
                                searchResultsArray.add(resultArray);
                            });

                    root.set(&quot;searchResults&quot;, searchResultsArray);

                    // Convert the response object to a JSON string
                    String jsonResponse = mapper.writeValueAsString(root);

                    out.tell(jsonResponse, getSelf());
                })
<span class="fc" id="L287">                .match(ProjectProtocol.UpdateDataResponse.class, message -&gt; {</span>
                    System.out.println(&quot;Received UpdateDataResponse&quot;);
                    // Received data update response, check if there is any actual update. If yes, call readability actor
                    String keyword = message.keyword;
                    // Get index of this keyword
                    int index = searchHistory.indexOf(keyword);
                    // Compare the results.
                    message.updatedData.thenAccept(results -&gt; {
                        boolean change = false;
                        for(int i=0; i&lt; searchResults.get(index).size(); i++){
                            // Compare each YTResponse.
                            if (!searchResults.get(index).get(i).equals(results.get(i))){
                                change = true;
                                break;
                            }
                        }
                        if(change){
                            // There is actual update in data, store the data
                            searchResults.set(index, (List&lt;YTResponse&gt;) results);
                            // Call the readability actor
                            readabilityActor.tell(new ProjectProtocol.ReadabilityUpdate(message.updatedData, keyword), getSelf());
                        }
                        // If there is no actual update in data, just do nothing.
                    });
                })
<span class="fc" id="L312">                .match(ProjectProtocol.ReadabilityUpdateResponse.class, message -&gt; {</span>
                    System.out.println(&quot;Received ReadabilityUpdateResponse&quot;);
                    // edit the readability information in list using keyword.
                    String keyword = message.keyword;
                    int index = searchHistory.indexOf(keyword);
                    avgFRE.set(index, message.avgFRE);
                    avgFKGL.set(index, message.avgFKGL);
                    List&lt;YTResponse&gt; responses = searchResults.get(index);
                    // Update all fre and fkgl value in target list.
                    IntStream.range(0, responses.size())
                            .forEach(i -&gt; {
                                YTResponse ytResponse = responses.get(i);
                                ytResponse.setFre(message.fre.get(i));
                                ytResponse.setFkgl(message.fkgl.get(i));
                            });
                })
<span class="fc" id="L328">                .match(WordStatsActor.WordStatsResults.class, message -&gt;{</span>
                    JsonNode wordStats = message.wordStats;
                    wordStatsMap.put(message.videoId, wordStats);
                })
<span class="fc" id="L332">                .build();</span>
    }

    /**
     * @author: Zheyi Zheng - 40266266
     * Created: 2024/11/14
     * This is the postStop method. This method cleanup scheduler.
     */
    @Override
    public void postStop() throws Exception {
<span class="pc bpc" id="L342" title="2 of 4 branches missed.">        if (refreshScheduler != null &amp;&amp; !refreshScheduler.isCancelled()) {</span>
            // Cleanup the scheduler
<span class="fc" id="L344">            refreshScheduler.cancel();</span>
        }
<span class="fc" id="L346">    }</span>

    /**
     * @author: Zheyi Zheng - 40266266
     * Created: 2024/11/24
     * This is the startScheduler class. This class setup a scheduler which send RefreshResults message to WebSocketActor every refreshInterval seconds.
     */
    private void startScheduler() {
<span class="fc" id="L354">        refreshScheduler = getContext().getSystem().scheduler().scheduleWithFixedDelay(</span>
<span class="fc" id="L355">                Duration.create(0, SECONDS),</span>
<span class="fc" id="L356">                Duration.create(refreshInterval, SECONDS),</span>
<span class="fc" id="L357">                getSelf(), // Send message to WebSocketActor itself</span>
                new RefreshResults(), // Message type is RefreshResults
<span class="fc" id="L359">                getContext().getDispatcher(), // Use the actor's dispatcher</span>
                null // No sender
        );
<span class="fc" id="L362">    }</span>

    /**
     * @author: Zheyi Zheng - 40266266
     * Created: 2024/11/24
     * This is the RefreshResults class. This class has nothing, only used as a message to let scheduler send data to view periodically.
     */
    private static class RefreshResults {
    }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>